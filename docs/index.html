<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="theme-color" content="#000000" />
  <meta name="description" content="AI-powered cryptocurrency trading assistant" />
  
  <title>HashTrade</title>
  
  <!-- PWA -->
  <link rel="manifest" href="manifest.json" />
  <link rel="apple-touch-icon" href="icon-192.png" />
  
  <!-- Syntax highlighting -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

  <style>
    :root {
      --neon: #00ff88;
      --neon-dim: #00ff8880;
      --neon-glow: rgba(0, 255, 136, 0.5);
      --neon-subtle: rgba(0, 255, 136, 0.08);
      --neon-border: rgba(0, 255, 136, 0.2);
      --bg: #000000;
      --bg-card: rgba(0, 20, 10, 0.6);
      --text: #e0ffe8;
      --text-dim: #a0c8b0;
      --muted: rgba(0, 255, 136, 0.4);
      --good: #00ff88;
      --bad: #ff4466;
      --warn: #ffcc00;
      --radius: 16px;
      --radius-sm: 10px;
      --safe-top: env(safe-area-inset-top, 0px);
      --safe-bottom: env(safe-area-inset-bottom, 0px);
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }
    
    html, body {
      height: 100%;
      font-family: -apple-system, BlinkMacSystemFont, 'SF Pro', 'Segoe UI', system-ui, sans-serif;
      background: var(--bg);
      color: var(--text);
      overflow: hidden;
      -webkit-font-smoothing: antialiased;
      -webkit-tap-highlight-color: transparent;
    }

    /* Ambient background */
    body::before {
      content: '';
      position: fixed;
      inset: 0;
      background: 
        radial-gradient(ellipse 100% 60% at 50% 0%, rgba(0, 255, 136, 0.08), transparent 60%),
        radial-gradient(circle at 20% 80%, rgba(0, 255, 136, 0.04), transparent 40%);
      pointer-events: none;
      z-index: 0;
    }

    .app {
      height: 100%;
      display: flex;
      flex-direction: column;
      position: relative;
      z-index: 1;
    }

    /* Header */
    header {
      flex-shrink: 0;
      padding: calc(var(--safe-top) + 12px) 16px 12px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: linear-gradient(180deg, rgba(0,0,0,0.9) 0%, transparent 100%);
      position: relative;
      z-index: 100;
    }

    .brand {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .logo {
      width: 36px;
      height: 36px;
      border-radius: 10px;
      background: conic-gradient(from 180deg, var(--neon), #00aa55, var(--neon));
      box-shadow: 0 0 20px var(--neon-glow);
      animation: logo-pulse 3s ease-in-out infinite;
    }

    @keyframes logo-pulse {
      0%, 100% { box-shadow: 0 0 20px var(--neon-glow); }
      50% { box-shadow: 0 0 30px var(--neon-glow), 0 0 40px rgba(0,255,136,0.2); }
    }

    .brand-text h1 {
      font-size: 18px;
      font-weight: 700;
      color: var(--neon);
      text-shadow: 0 0 20px var(--neon-glow);
      letter-spacing: -0.5px;
    }

    .brand-text .status {
      font-size: 11px;
      color: var(--muted);
      display: flex;
      align-items: center;
      gap: 5px;
    }

    .status-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: var(--bad);
    }

    .status-dot.connected {
      background: var(--good);
      box-shadow: 0 0 8px var(--neon-glow);
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    .header-actions {
      display: flex;
      gap: 8px;
    }

    .icon-btn {
      width: 40px;
      height: 40px;
      border-radius: var(--radius-sm);
      border: 1px solid var(--neon-border);
      background: var(--neon-subtle);
      color: var(--neon);
      font-size: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.2s;
    }

    .icon-btn:active {
      transform: scale(0.95);
      background: rgba(0, 255, 136, 0.15);
    }

    /* Main chat/timeline area */
    .timeline-container {
      flex: 1;
      overflow-y: auto;
      overflow-x: hidden;
      padding: 0 12px 120px;
      scroll-behavior: smooth;
      -webkit-overflow-scrolling: touch;
    }

    .timeline {
      display: flex;
      flex-direction: column;
      gap: 12px;
      padding-top: 8px;
    }

    /* Message bubbles */
    .message {
      max-width: 92%;
      animation: fadeSlideIn 0.3s ease;
    }

    @keyframes fadeSlideIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .message.user {
      align-self: flex-end;
    }

    .message.assistant {
      align-self: flex-start;
    }

    .message.history {
      align-self: stretch;
      max-width: 100%;
    }

    .bubble {
      padding: 12px 16px;
      border-radius: var(--radius);
      font-size: 15px;
      line-height: 1.5;
      word-wrap: break-word;
    }

    .message.user .bubble {
      background: linear-gradient(135deg, var(--neon) 0%, #00cc66 100%);
      color: #000;
      border-bottom-right-radius: 4px;
      font-weight: 500;
    }

    .message.assistant .bubble {
      background: var(--bg-card);
      border: 1px solid var(--neon-border);
      border-bottom-left-radius: 4px;
      backdrop-filter: blur(10px);
    }

    .message.assistant .bubble pre {
      background: rgba(0, 0, 0, 0.4);
      border-radius: 8px;
      padding: 12px;
      overflow-x: auto;
      margin: 8px 0;
      font-size: 13px;
    }

    .message.assistant .bubble code {
      font-family: 'SF Mono', Monaco, monospace;
      font-size: 13px;
    }

    .message.assistant .bubble p { margin: 0.5em 0; }
    .message.assistant .bubble p:first-child { margin-top: 0; }
    .message.assistant .bubble p:last-child { margin-bottom: 0; }

    /* History/Event cards */
    .event-card {
      background: var(--bg-card);
      border: 1px solid var(--neon-border);
      border-radius: var(--radius);
      padding: 14px 16px;
      backdrop-filter: blur(10px);
    }

    .event-card.order {
      border-left: 3px solid var(--good);
    }

    .event-card.trade {
      border-left: 3px solid #00ccff;
    }

    .event-card.signal {
      border-left: 3px solid var(--warn);
    }

    .event-card.theme {
      border-left: 3px solid #ff00ff;
    }

    .event-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }

    .event-type {
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: var(--neon);
      padding: 3px 8px;
      background: var(--neon-subtle);
      border-radius: 4px;
    }

    .event-time {
      font-size: 11px;
      color: var(--muted);
      font-family: 'SF Mono', monospace;
    }

    .event-content {
      font-size: 14px;
      color: var(--text);
      line-height: 1.5;
    }

    .event-content strong {
      color: var(--neon);
    }

    /* Tool status indicators */
    .tool-indicator {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 12px;
      margin: 6px 0;
      border-radius: 20px;
      font-size: 12px;
      background: var(--neon-subtle);
      border: 1px solid var(--neon-border);
      color: var(--muted);
    }

    .tool-indicator.running {
      border-color: var(--neon-dim);
    }

    .tool-indicator.success {
      color: var(--good);
      border-color: rgba(0, 255, 136, 0.4);
    }

    .tool-indicator.error {
      color: var(--bad);
      border-color: rgba(255, 68, 102, 0.4);
    }

    .tool-spinner {
      width: 12px;
      height: 12px;
      border: 2px solid var(--neon-border);
      border-top-color: var(--neon);
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* Typing indicator */
    .typing-indicator {
      display: flex;
      gap: 4px;
      padding: 12px 16px;
    }

    .typing-indicator span {
      width: 8px;
      height: 8px;
      background: var(--neon);
      border-radius: 50%;
      animation: typing 1.4s infinite;
    }

    .typing-indicator span:nth-child(2) { animation-delay: 0.2s; }
    .typing-indicator span:nth-child(3) { animation-delay: 0.4s; }

    @keyframes typing {
      0%, 60%, 100% { transform: translateY(0); opacity: 0.4; }
      30% { transform: translateY(-8px); opacity: 1; }
    }

    /* Input area */
    .input-area {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      padding: 12px 12px calc(var(--safe-bottom) + 12px);
      background: linear-gradient(0deg, rgba(0,0,0,0.95) 0%, rgba(0,0,0,0.8) 80%, transparent 100%);
      z-index: 100;
    }

    .input-row {
      display: flex;
      gap: 10px;
      align-items: flex-end;
    }

    .input-wrap {
      flex: 1;
      position: relative;
    }

    .chat-input {
      width: 100%;
      min-height: 48px;
      max-height: 120px;
      padding: 14px 16px;
      border-radius: var(--radius);
      border: 1px solid var(--neon-border);
      background: var(--bg-card);
      color: var(--text);
      font-size: 16px;
      line-height: 1.4;
      resize: none;
      outline: none;
      font-family: inherit;
      transition: border-color 0.2s, box-shadow 0.2s;
    }

    .chat-input:focus {
      border-color: var(--neon-dim);
      box-shadow: 0 0 20px rgba(0, 255, 136, 0.1);
    }

    .chat-input::placeholder {
      color: var(--muted);
    }

    .send-btn {
      width: 48px;
      height: 48px;
      border-radius: var(--radius);
      border: none;
      background: var(--neon);
      color: #000;
      font-size: 20px;
      font-weight: 700;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
      box-shadow: 0 0 20px var(--neon-glow);
    }

    .send-btn:active {
      transform: scale(0.95);
    }

    .send-btn:disabled {
      opacity: 0.5;
      box-shadow: none;
    }

    /* Chart overlay */
    .chart-fab {
      position: fixed;
      bottom: calc(var(--safe-bottom) + 80px);
      right: 16px;
      width: 56px;
      height: 56px;
      border-radius: 50%;
      border: 2px solid var(--neon);
      background: var(--bg);
      color: var(--neon);
      font-size: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 99;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5), 0 0 30px var(--neon-glow);
      transition: all 0.3s;
    }

    .chart-fab:active {
      transform: scale(0.95);
    }

    .chart-fab .badge {
      position: absolute;
      top: -4px;
      right: -4px;
      min-width: 20px;
      height: 20px;
      padding: 0 6px;
      border-radius: 10px;
      background: var(--neon);
      color: #000;
      font-size: 11px;
      font-weight: 700;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    /* Chart modal */
    .chart-modal {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.95);
      z-index: 1000;
      display: none;
      flex-direction: column;
      opacity: 0;
      transition: opacity 0.3s;
    }

    .chart-modal.show {
      display: flex;
      opacity: 1;
    }

    .chart-header {
      padding: calc(var(--safe-top) + 12px) 16px 12px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid var(--neon-border);
    }

    .chart-title {
      font-size: 16px;
      font-weight: 600;
      color: var(--neon);
    }

    .chart-meta {
      font-size: 12px;
      color: var(--muted);
    }

    .chart-close {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      border: 1px solid var(--neon-border);
      background: transparent;
      color: var(--text);
      font-size: 24px;
      cursor: pointer;
    }

    .chart-body {
      flex: 1;
      padding: 16px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .chart-controls {
      display: flex;
      gap: 8px;
      overflow-x: auto;
      padding-bottom: 8px;
    }

    .chart-controls::-webkit-scrollbar { display: none; }

    .tf-btn {
      padding: 8px 16px;
      border-radius: 20px;
      border: 1px solid var(--neon-border);
      background: transparent;
      color: var(--text-dim);
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      white-space: nowrap;
      transition: all 0.2s;
    }

    .tf-btn.active {
      background: var(--neon);
      color: #000;
      border-color: var(--neon);
    }

    .chart-canvas-wrap {
      flex: 1;
      border: 1px solid var(--neon-border);
      border-radius: var(--radius);
      overflow: hidden;
      background: rgba(0, 20, 10, 0.5);
    }

    .chart-canvas-wrap canvas {
      width: 100%;
      height: 100%;
    }

    .chart-info {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 8px;
    }

    .chart-stat {
      text-align: center;
      padding: 12px 8px;
      background: var(--bg-card);
      border-radius: var(--radius-sm);
      border: 1px solid var(--neon-border);
    }

    .chart-stat-label {
      font-size: 10px;
      text-transform: uppercase;
      color: var(--muted);
      margin-bottom: 4px;
    }

    .chart-stat-value {
      font-size: 14px;
      font-weight: 600;
      color: var(--text);
      font-family: 'SF Mono', monospace;
    }

    .chart-stat-value.up { color: var(--good); }
    .chart-stat-value.down { color: var(--bad); }

    /* Settings modal */
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.9);
      z-index: 1000;
      display: none;
      align-items: flex-end;
      justify-content: center;
    }

    .modal-overlay.show {
      display: flex;
    }

    .modal-sheet {
      width: 100%;
      max-width: 500px;
      max-height: 85vh;
      background: var(--bg);
      border-top-left-radius: 24px;
      border-top-right-radius: 24px;
      padding: 20px 20px calc(var(--safe-bottom) + 20px);
      overflow-y: auto;
      animation: slideUp 0.3s ease;
    }

    @keyframes slideUp {
      from { transform: translateY(100%); }
      to { transform: translateY(0); }
    }

    .modal-handle {
      width: 40px;
      height: 4px;
      background: var(--neon-border);
      border-radius: 2px;
      margin: 0 auto 20px;
    }

    .modal-title {
      font-size: 20px;
      font-weight: 700;
      color: var(--neon);
      margin-bottom: 24px;
    }

    .form-group {
      margin-bottom: 20px;
    }

    .form-label {
      display: block;
      font-size: 12px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: var(--muted);
      margin-bottom: 8px;
    }

    .form-input, .form-select {
      width: 100%;
      padding: 14px 16px;
      border-radius: var(--radius-sm);
      border: 1px solid var(--neon-border);
      background: var(--bg-card);
      color: var(--text);
      font-size: 16px;
      outline: none;
      font-family: inherit;
    }

    .form-input:focus, .form-select:focus {
      border-color: var(--neon-dim);
    }

    .form-select {
      appearance: none;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%2300ff88' d='M6 8L1 3h10z'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 16px center;
      padding-right: 40px;
    }

    .form-row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }

    .btn {
      width: 100%;
      padding: 16px;
      border-radius: var(--radius);
      border: none;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }

    .btn-primary {
      background: var(--neon);
      color: #000;
    }

    .btn-secondary {
      background: var(--neon-subtle);
      color: var(--neon);
      border: 1px solid var(--neon-border);
    }

    .btn-row {
      display: flex;
      gap: 12px;
      margin-top: 24px;
    }

    .btn-row .btn {
      flex: 1;
    }

    /* Time travel overlay */
    .time-travel {
      position: fixed;
      top: calc(var(--safe-top) + 70px);
      left: 12px;
      right: 12px;
      padding: 12px 16px;
      background: rgba(0, 0, 0, 0.9);
      border: 1px solid var(--neon-border);
      border-radius: var(--radius);
      backdrop-filter: blur(20px);
      z-index: 200;
      display: none;
      flex-direction: column;
      gap: 10px;
      animation: slideDown 0.3s ease;
    }

    .time-travel.show {
      display: flex;
    }

    @keyframes slideDown {
      from { opacity: 0; transform: translateY(-20px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .time-travel-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .time-travel-title {
      font-size: 12px;
      font-weight: 600;
      color: var(--neon);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .time-travel-close {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      border: none;
      background: var(--neon-subtle);
      color: var(--text);
      font-size: 16px;
      cursor: pointer;
    }

    .time-travel-controls {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .time-btn {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      border: 1px solid var(--neon-border);
      background: var(--neon-subtle);
      color: var(--neon);
      font-size: 14px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
    }

    .time-btn:active {
      transform: scale(0.95);
      background: rgba(0, 255, 136, 0.2);
    }

    .time-btn.play {
      width: 44px;
      height: 44px;
      background: var(--neon);
      color: #000;
      border: none;
      font-size: 16px;
    }

    .time-slider-wrap {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .time-slider {
      width: 100%;
      height: 6px;
      -webkit-appearance: none;
      appearance: none;
      background: var(--neon-border);
      border-radius: 3px;
      outline: none;
    }

    .time-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: var(--neon);
      cursor: pointer;
      box-shadow: 0 0 10px var(--neon-glow);
    }

    .time-slider::-moz-range-thumb {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: var(--neon);
      cursor: pointer;
      border: none;
    }

    .time-readout {
      font-size: 11px;
      color: var(--muted);
      font-family: 'SF Mono', monospace;
      text-align: center;
    }

    .live-badge {
      display: inline-flex;
      align-items: center;
      gap: 5px;
      padding: 4px 10px;
      border-radius: 12px;
      background: rgba(0, 255, 136, 0.15);
      border: 1px solid var(--neon-dim);
      font-size: 11px;
      font-weight: 600;
      color: var(--neon);
    }

    .live-badge.paused {
      background: rgba(255, 204, 0, 0.15);
      border-color: var(--warn);
      color: var(--warn);
    }

    .live-badge .dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: var(--neon);
      animation: pulse 1.5s infinite;
    }

    .live-badge.paused .dot {
      background: var(--warn);
      animation: none;
    }

    /* Time travel FAB */
    .time-fab {
      position: fixed;
      bottom: calc(var(--safe-bottom) + 80px);
      left: 16px;
      width: 48px;
      height: 48px;
      border-radius: 50%;
      border: 1px solid var(--neon-border);
      background: var(--bg);
      color: var(--neon);
      font-size: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 99;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
      transition: all 0.3s;
    }

    .time-fab:active {
      transform: scale(0.95);
    }

    .time-fab.has-history {
      border-color: var(--neon-dim);
      box-shadow: 0 0 15px var(--neon-glow);
    }

    /* Toast notifications */
    .toast-container {
      position: fixed;
      top: calc(var(--safe-top) + 70px);
      left: 12px;
      right: 12px;
      z-index: 2000;
      display: flex;
      flex-direction: column;
      gap: 8px;
      pointer-events: none;
    }

    .toast {
      padding: 14px 16px;
      border-radius: var(--radius-sm);
      background: var(--bg-card);
      border: 1px solid var(--neon-border);
      backdrop-filter: blur(10px);
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 14px;
      animation: toastIn 0.3s ease, toastOut 0.3s ease 2.7s forwards;
      pointer-events: auto;
    }

    .toast.success { border-color: var(--good); }
    .toast.error { border-color: var(--bad); }
    .toast.warning { border-color: var(--warn); }

    .toast-icon {
      font-size: 18px;
    }

    @keyframes toastIn {
      from { opacity: 0; transform: translateY(-20px); }
      to { opacity: 1; transform: translateY(0); }
    }

    @keyframes toastOut {
      from { opacity: 1; }
      to { opacity: 0; transform: translateY(-10px); }
    }

    /* Empty state */
    .empty-state {
      text-align: center;
      padding: 60px 20px;
      color: var(--muted);
    }

    .empty-state-icon {
      font-size: 48px;
      margin-bottom: 16px;
      opacity: 0.5;
    }

    .empty-state-text {
      font-size: 15px;
      line-height: 1.5;
    }

    /* Scrollbar */
    ::-webkit-scrollbar { width: 4px; height: 4px; }
    ::-webkit-scrollbar-track { background: transparent; }
    ::-webkit-scrollbar-thumb { background: var(--neon-border); border-radius: 2px; }

    /* Desktop adjustments */
    @media (min-width: 768px) {
      .timeline-container { padding: 0 24px 140px; }
      .input-area { padding: 16px 24px calc(var(--safe-bottom) + 16px); }
      .message { max-width: 70%; }
      .modal-sheet { border-radius: 24px; margin-bottom: 20px; }
    }
  </style>
</head>
<body>
  <div class="app">
    <!-- Header -->
    <header>
      <div class="brand">
        <div class="logo"></div>
        <div class="brand-text">
          <h1>HashTrade</h1>
          <div class="status">
            <span class="status-dot" id="statusDot"></span>
            <span id="statusText">Disconnected</span>
          </div>
        </div>
      </div>
      <div class="header-actions">
        <button class="icon-btn" id="btnClear" title="Clear">üóë</button>
        <button class="icon-btn" id="btnSettings" title="Settings">‚öôÔ∏è</button>
      </div>
    </header>

    <!-- Main timeline -->
    <div class="timeline-container" id="timelineContainer">
      <div class="timeline" id="timeline">
        <div class="empty-state" id="emptyState">
          <div class="empty-state-icon">üìä</div>
          <div class="empty-state-text">
            Start trading with AI<br>
            <span style="color: var(--neon);">Try: "buy 10 USDT of BTC"</span>
          </div>
        </div>
      </div>
    </div>

    <!-- Time Travel FAB -->
    <button class="time-fab" id="timeFab" title="Time Travel">‚è±</button>

    <!-- Chart FAB -->
    <button class="chart-fab" id="chartFab">
      üìà
      <span class="badge" id="chartBadge" style="display: none;">!</span>
    </button>

    <!-- Time Travel Overlay -->
    <div class="time-travel" id="timeTravel">
      <div class="time-travel-header">
        <span class="time-travel-title">‚è± Time Travel</span>
        <div style="display: flex; align-items: center; gap: 10px;">
          <div class="live-badge" id="liveBadge">
            <span class="dot"></span>
            <span id="liveText">LIVE</span>
          </div>
          <button class="time-travel-close" id="timeTravelClose">√ó</button>
        </div>
      </div>
      <div class="time-travel-controls">
        <button class="time-btn" id="btnPrev">‚ü®</button>
        <button class="time-btn play" id="btnPlay">‚ñ∂</button>
        <button class="time-btn" id="btnNext">‚ü©</button>
        <div class="time-slider-wrap">
          <input type="range" class="time-slider" id="timeSlider" min="0" max="0" value="0" />
          <div class="time-readout" id="timeReadout">No events yet</div>
        </div>
        <button class="time-btn" id="btnLive" title="Go to Live">‚ü≤</button>
      </div>
    </div>

    <!-- Input area -->
    <div class="input-area">
      <div class="input-row">
        <div class="input-wrap">
          <textarea 
            class="chat-input" 
            id="chatInput" 
            placeholder="Ask anything... buy BTC, check balance, change theme"
            rows="1"
          ></textarea>
        </div>
        <button class="send-btn" id="btnSend">‚Üë</button>
      </div>
    </div>
  </div>

  <!-- Chart Modal -->
  <div class="chart-modal" id="chartModal">
    <div class="chart-header">
      <div>
        <div class="chart-title" id="chartSymbol">BTC/USDT</div>
        <div class="chart-meta" id="chartMeta">Loading...</div>
      </div>
      <button class="chart-close" id="chartClose">√ó</button>
    </div>
    <div class="chart-body">
      <div class="chart-controls" id="chartControls">
        <button class="tf-btn active" data-tf="1m">1m</button>
        <button class="tf-btn" data-tf="5m">5m</button>
        <button class="tf-btn" data-tf="15m">15m</button>
        <button class="tf-btn" data-tf="1h">1H</button>
        <button class="tf-btn" data-tf="4h">4H</button>
        <button class="tf-btn" data-tf="1d">1D</button>
      </div>
      <div class="chart-canvas-wrap">
        <canvas id="chartCanvas"></canvas>
      </div>
      <div class="chart-info">
        <div class="chart-stat">
          <div class="chart-stat-label">Price</div>
          <div class="chart-stat-value" id="statPrice">--</div>
        </div>
        <div class="chart-stat">
          <div class="chart-stat-label">24h</div>
          <div class="chart-stat-value" id="stat24h">--</div>
        </div>
        <div class="chart-stat">
          <div class="chart-stat-label">High</div>
          <div class="chart-stat-value" id="statHigh">--</div>
        </div>
        <div class="chart-stat">
          <div class="chart-stat-label">Low</div>
          <div class="chart-stat-value" id="statLow">--</div>
        </div>
      </div>
    </div>
  </div>

  <!-- Settings Modal -->
  <div class="modal-overlay" id="settingsModal">
    <div class="modal-sheet">
      <div class="modal-handle"></div>
      <div class="modal-title">‚öôÔ∏è Settings</div>
      
      <div class="form-group">
        <label class="form-label">WebSocket Server</label>
        <input type="text" class="form-input" id="settingsWsUrl" value="ws://127.0.0.1:8090" />
      </div>

      <div class="form-group">
        <label class="form-label">Exchange</label>
        <select class="form-select" id="settingsExchange">
          <option value="bybit">Bybit</option>
          <option value="binance">Binance</option>
          <option value="okx">OKX</option>
          <option value="kucoin">KuCoin</option>
          <option value="kraken">Kraken</option>
        </select>
      </div>

      <div class="form-group">
        <label class="form-label">API Key</label>
        <input type="text" class="form-input" id="settingsApiKey" placeholder="Optional - for trading" autocomplete="off" />
      </div>

      <div class="form-group">
        <label class="form-label">API Secret</label>
        <input type="password" class="form-input" id="settingsApiSecret" placeholder="Optional - for trading" autocomplete="off" />
      </div>

      <div class="form-row">
        <div class="form-group">
          <label class="form-label">Symbol</label>
          <input type="text" class="form-input" id="settingsSymbol" value="BTC/USDT" />
        </div>
        <div class="form-group">
          <label class="form-label">Timeframe</label>
          <select class="form-select" id="settingsTimeframe">
            <option value="1m">1 minute</option>
            <option value="5m">5 minutes</option>
            <option value="15m">15 minutes</option>
            <option value="1h">1 hour</option>
          </select>
        </div>
      </div>

      <div class="btn-row">
        <button class="btn btn-secondary" id="btnSettingsCancel">Cancel</button>
        <button class="btn btn-primary" id="btnSettingsSave">Save & Connect</button>
      </div>
    </div>
  </div>

  <!-- Toast container -->
  <div class="toast-container" id="toastContainer"></div>

  <script>
    // Initialize markdown
    marked.setOptions({
      highlight: (code, lang) => {
        try {
          if (lang && hljs.getLanguage(lang)) return hljs.highlight(code, {language: lang}).value;
          return hljs.highlightAuto(code).value;
        } catch { return code; }
      },
      breaks: true,
      gfm: true
    });

    // State
    const state = {
      ws: null,
      connected: false,
      settings: {
        wsUrl: 'ws://127.0.0.1:8090',
        exchange: 'bybit',
        apiKey: '',
        apiSecret: '',
        symbol: 'BTC/USDT',
        timeframe: '1m'
      },
      chart: { ohlcv: [], symbol: 'BTC/USDT', timeframe: '1m' },
      turns: new Map(),
      historyItems: [],
      // Time travel state
      streamEvents: [],
      streamSnaps: [],
      nowIndex: 0,
      playing: false,
      playTimer: null,
      isLive: true
    };

    // Elements
    const els = {
      timeline: document.getElementById('timeline'),
      timelineContainer: document.getElementById('timelineContainer'),
      emptyState: document.getElementById('emptyState'),
      chatInput: document.getElementById('chatInput'),
      btnSend: document.getElementById('btnSend'),
      statusDot: document.getElementById('statusDot'),
      statusText: document.getElementById('statusText'),
      chartModal: document.getElementById('chartModal'),
      chartCanvas: document.getElementById('chartCanvas'),
      settingsModal: document.getElementById('settingsModal'),
      toastContainer: document.getElementById('toastContainer'),
      // Time travel elements
      timeTravel: document.getElementById('timeTravel'),
      timeFab: document.getElementById('timeFab'),
      timeSlider: document.getElementById('timeSlider'),
      timeReadout: document.getElementById('timeReadout'),
      liveBadge: document.getElementById('liveBadge'),
      liveText: document.getElementById('liveText')
    };

    // Load settings
    function loadSettings() {
      try {
        const saved = localStorage.getItem('hashtradeSettings');
        if (saved) Object.assign(state.settings, JSON.parse(saved));
      } catch (e) {}
      
      document.getElementById('settingsWsUrl').value = state.settings.wsUrl;
      document.getElementById('settingsExchange').value = state.settings.exchange;
      document.getElementById('settingsApiKey').value = state.settings.apiKey;
      document.getElementById('settingsApiSecret').value = state.settings.apiSecret;
      document.getElementById('settingsSymbol').value = state.settings.symbol;
      document.getElementById('settingsTimeframe').value = state.settings.timeframe;
      state.chart.symbol = state.settings.symbol;
      state.chart.timeframe = state.settings.timeframe;
    }

    function saveSettings() {
      state.settings.wsUrl = document.getElementById('settingsWsUrl').value;
      state.settings.exchange = document.getElementById('settingsExchange').value;
      state.settings.apiKey = document.getElementById('settingsApiKey').value;
      state.settings.apiSecret = document.getElementById('settingsApiSecret').value;
      state.settings.symbol = document.getElementById('settingsSymbol').value;
      state.settings.timeframe = document.getElementById('settingsTimeframe').value;
      
      localStorage.setItem('hashtradeSettings', JSON.stringify(state.settings));
      state.chart.symbol = state.settings.symbol;
      state.chart.timeframe = state.settings.timeframe;
      
      closeSettings();
      connect();
    }

    // Toast notifications
    function showToast(message, type = 'info') {
      const icons = { success: '‚úì', error: '‚úó', warning: '‚ö†', info: '‚Ñπ' };
      const toast = document.createElement('div');
      toast.className = `toast ${type}`;
      toast.innerHTML = `<span class="toast-icon">${icons[type] || '‚Ä¢'}</span><span>${message}</span>`;
      els.toastContainer.appendChild(toast);
      setTimeout(() => toast.remove(), 3000);
    }

    // ========== TIME TRAVEL ==========
    
    function isoNow() { return new Date().toISOString(); }

    function addStreamEvent(type, msg) {
      state.streamEvents.push({ ts: isoNow(), type, msg });
      buildStreamSnaps();
      
      // Update FAB to show history exists
      els.timeFab.classList.add('has-history');
      
      // If we're live, follow along
      if (state.isLive) {
        state.nowIndex = state.streamEvents.length - 1;
        els.timeSlider.value = state.nowIndex;
        updateTimeReadout();
      }
    }

    function buildStreamSnaps() {
      const snaps = [];
      let chart = null;
      let historyUpToNow = [];
      
      for (let i = 0; i < state.streamEvents.length; i++) {
        const e = state.streamEvents[i];
        if (e.type === 'ohlcv') chart = e.msg.data;
        if (e.type === 'history') historyUpToNow = [...historyUpToNow, e.msg.data];
        if (e.type === 'history_sync') historyUpToNow = Array.isArray(e.msg.data) ? [...e.msg.data] : [];
        if (e.type === 'history_cleared') historyUpToNow = [];
        
        snaps.push({
          i,
          ts: e.ts,
          chart,
          history: [...historyUpToNow],
          events: state.streamEvents.slice(0, i + 1)
        });
      }
      
      state.streamSnaps = snaps;
      els.timeSlider.max = Math.max(0, snaps.length - 1);
    }

    function setTimeIndex(i) {
      state.nowIndex = Math.max(0, Math.min(i, state.streamSnaps.length - 1));
      state.isLive = state.nowIndex >= state.streamSnaps.length - 1;
      
      els.timeSlider.value = state.nowIndex;
      updateTimeReadout();
      updateLiveBadge();
      renderFromSnapshot();
    }

    function updateTimeReadout() {
      const snap = state.streamSnaps[state.nowIndex];
      if (!snap) {
        els.timeReadout.textContent = 'No events yet';
        return;
      }
      
      const total = state.streamSnaps.length;
      const timeStr = snap.ts ? snap.ts.split('T')[1]?.split('.')[0] || '' : '';
      els.timeReadout.textContent = `${state.nowIndex + 1} / ${total} ‚Ä¢ ${timeStr}`;
    }

    function updateLiveBadge() {
      if (state.isLive) {
        els.liveBadge.classList.remove('paused');
        els.liveText.textContent = 'LIVE';
      } else {
        els.liveBadge.classList.add('paused');
        els.liveText.textContent = 'PAUSED';
      }
    }

    function goToLive() {
      state.isLive = true;
      setTimeIndex(state.streamSnaps.length - 1);
    }

    function togglePlay() {
      state.playing = !state.playing;
      const btn = document.getElementById('btnPlay');
      
      if (state.playing) {
        btn.textContent = '‚è∏';
        state.playTimer = setInterval(() => {
          if (state.nowIndex >= state.streamSnaps.length - 1) {
            state.playing = false;
            btn.textContent = '‚ñ∂';
            clearInterval(state.playTimer);
            state.isLive = true;
            updateLiveBadge();
            return;
          }
          setTimeIndex(state.nowIndex + 1);
        }, 300);
      } else {
        btn.textContent = '‚ñ∂';
        clearInterval(state.playTimer);
      }
    }

    function renderFromSnapshot() {
      const snap = state.streamSnaps[state.nowIndex];
      if (!snap) return;

      // Clear and rebuild timeline from snapshot
      clearTimelineKeepEmpty();
      state.turns.clear();

      // Replay events up to this point
      for (const e of snap.events) {
        const msg = e.msg || {};
        
        switch (e.type) {
          case 'turn_start':
            createTurn(msg.turn_id, msg.data || '', true);
            break;
          case 'chunk':
            appendToTurn(msg.turn_id, msg.data || '');
            break;
          case 'tool_start':
            addToolIndicator(msg.turn_id, msg.data || 'tool', 'running');
            break;
          case 'tool_end':
            updateToolIndicator(msg.turn_id, !!msg.success);
            break;
          case 'turn_end':
            finalizeTurn(msg.turn_id);
            break;
          case 'history':
            if (msg.data) addHistoryItem(msg.data, true);
            break;
        }
      }

      // Update chart if available
      if (snap.chart) {
        state.chart = snap.chart;
        if (els.chartModal.classList.contains('show')) {
          updateChartStats();
          drawChart();
        }
      }

      scrollToBottom();
    }

    function clearTimelineKeepEmpty() {
      els.timeline.innerHTML = '';
      if (els.emptyState) {
        els.timeline.appendChild(els.emptyState);
      }
    }

    function openTimeTravel() {
      els.timeTravel.classList.add('show');
    }

    function closeTimeTravel() {
      els.timeTravel.classList.remove('show');
    }

    // WebSocket
    function connect() {
      if (state.ws) {
        state.ws.close();
      }

      state.ws = new WebSocket(state.settings.wsUrl);
      els.statusText.textContent = 'Connecting...';

      state.ws.onopen = () => {
        state.connected = true;
        els.statusDot.classList.add('connected');
        els.statusText.textContent = 'Connected';
        showToast('Connected to server', 'success');
        
        // Send credentials
        state.ws.send(JSON.stringify({
          type: 'credentials',
          exchange: state.settings.exchange,
          apiKey: state.settings.apiKey,
          apiSecret: state.settings.apiSecret
        }));
        
        // Request initial chart
        requestChart();
      };

      state.ws.onclose = () => {
        state.connected = false;
        els.statusDot.classList.remove('connected');
        els.statusText.textContent = 'Disconnected';
      };

      state.ws.onerror = () => {
        showToast('Connection error', 'error');
      };

      state.ws.onmessage = handleMessage;
    }

    function handleMessage(ev) {
      let msg;
      try { msg = JSON.parse(ev.data); } catch { return; }
      
      const t = msg.type;

      // Track all events for time travel
      if (['turn_start', 'chunk', 'tool_start', 'tool_end', 'turn_end', 'history', 'history_sync', 'history_cleared', 'ohlcv', 'theme_update', 'ui_alert'].includes(t)) {
        addStreamEvent(t, msg);
      }

      // If not live, don't update UI from new messages
      if (!state.isLive && !['history_sync', 'ohlcv'].includes(t)) {
        return;
      }

      switch (t) {
        case 'connected':
          break;

        case 'turn_start':
          createTurn(msg.turn_id, msg.data);
          break;

        case 'chunk':
          appendToTurn(msg.turn_id, msg.data);
          break;

        case 'tool_start':
          addToolIndicator(msg.turn_id, msg.data, 'running');
          break;

        case 'tool_end':
          updateToolIndicator(msg.turn_id, msg.success);
          break;

        case 'turn_end':
          finalizeTurn(msg.turn_id);
          break;

        case 'history_sync':
          state.historyItems = Array.isArray(msg.data) ? msg.data : [];
          renderHistory();
          break;

        case 'history':
          if (msg.data) {
            state.historyItems.push(msg.data);
            addHistoryItem(msg.data);
          }
          break;

        case 'history_cleared':
          state.historyItems = [];
          clearTimeline();
          break;

        case 'ohlcv':
          if (msg.data) {
            state.chart = msg.data;
            updateChartStats();
            if (els.chartModal.classList.contains('show')) {
              drawChart();
            }
          }
          break;

        case 'theme_update':
          applyTheme(msg.data);
          break;

        case 'ui_alert':
          showToast(msg.content, msg.alert_type || 'info');
          break;
      }
    }

    // Timeline management
    function hideEmptyState() {
      if (els.emptyState) els.emptyState.style.display = 'none';
    }

    function clearTimeline() {
      els.timeline.innerHTML = '';
      state.turns.clear();
      els.emptyState.style.display = 'block';
      els.timeline.appendChild(els.emptyState);
    }

    function createTurn(turnId, userMessage, isReplay = false) {
      hideEmptyState();
      
      // User message
      const userEl = document.createElement('div');
      userEl.className = 'message user';
      userEl.innerHTML = `<div class="bubble">${escapeHtml(userMessage)}</div>`;
      els.timeline.appendChild(userEl);

      // Assistant message container
      const assistantEl = document.createElement('div');
      assistantEl.className = 'message assistant';
      assistantEl.dataset.turnId = turnId;
      
      const bubble = document.createElement('div');
      bubble.className = 'bubble';
      
      const content = document.createElement('div');
      content.className = 'content';
      
      const typing = document.createElement('div');
      typing.className = 'typing-indicator';
      typing.innerHTML = '<span></span><span></span><span></span>';
      
      bubble.appendChild(content);
      if (!isReplay) bubble.appendChild(typing);
      assistantEl.appendChild(bubble);
      els.timeline.appendChild(assistantEl);

      state.turns.set(turnId, { el: assistantEl, content, typing, bubble, text: '', tools: [] });
      if (!isReplay) scrollToBottom();
    }

    function appendToTurn(turnId, text) {
      const turn = state.turns.get(turnId);
      if (!turn) return;
      
      turn.text += (text || '');
      turn.content.innerHTML = marked.parse(turn.text);
      turn.content.querySelectorAll('pre code').forEach(block => hljs.highlightElement(block));
      scrollToBottom();
    }

    function addToolIndicator(turnId, toolName, status) {
      const turn = state.turns.get(turnId);
      if (!turn) return;

      const indicator = document.createElement('div');
      indicator.className = `tool-indicator ${status}`;
      indicator.innerHTML = `<div class="tool-spinner"></div><span>${toolName}</span>`;
      turn.bubble.insertBefore(indicator, turn.content);
      turn.tools.push(indicator);
    }

    function updateToolIndicator(turnId, success) {
      const turn = state.turns.get(turnId);
      if (!turn || !turn.tools.length) return;
      
      const last = turn.tools[turn.tools.length - 1];
      last.className = `tool-indicator ${success ? 'success' : 'error'}`;
      last.innerHTML = `<span>${success ? '‚úì' : '‚úó'}</span>${last.querySelector('span:last-child').textContent}`;
    }

    function finalizeTurn(turnId) {
      const turn = state.turns.get(turnId);
      if (!turn) return;
      turn.typing.remove();
    }

    function addHistoryItem(item, isReplay = false) {
      hideEmptyState();
      
      const type = item.type || 'note';
      const data = item.data || {};
      const ts = item.ts ? new Date(item.ts * 1000).toLocaleTimeString() : '';
      
      // Skip UI/tool events
      if (['tool_start', 'tool_end', 'ui', 'balance', 'raw'].includes(type)) return;

      const el = document.createElement('div');
      el.className = 'message history';
      
      let content = '';
      if (typeof data === 'string') {
        content = data;
      } else if (data.message) {
        content = data.message;
      } else if (data.symbol) {
        content = `<strong>${(data.side || type).toUpperCase()}</strong> ${data.amount || ''} ${data.symbol} ${data.price ? '@ ' + data.price : ''}`;
      } else {
        content = JSON.stringify(data);
      }

      el.innerHTML = `
        <div class="event-card ${type}">
          <div class="event-header">
            <span class="event-type">${type}</span>
            <span class="event-time">${ts}</span>
          </div>
          <div class="event-content">${content}</div>
        </div>
      `;
      
      els.timeline.appendChild(el);
      if (!isReplay) scrollToBottom();
    }

    function renderHistory() {
      // Keep existing turns, just add history items
      const SKIP = new Set(['tool_start', 'tool_end', 'ui', 'balance', 'raw']);
      for (const item of state.historyItems.slice(-50)) {
        if (!SKIP.has(item.type)) {
          addHistoryItem(item);
        }
      }
    }

    function scrollToBottom() {
      requestAnimationFrame(() => {
        els.timelineContainer.scrollTop = els.timelineContainer.scrollHeight;
      });
    }

    // Send message
    function send() {
      const text = els.chatInput.value.trim();
      if (!text || !state.connected) return;
      
      els.chatInput.value = '';
      els.chatInput.style.height = 'auto';
      state.ws.send(text);
    }

    // Chart
    function requestChart() {
      if (!state.ws || state.ws.readyState !== 1) return;
      state.ws.send(JSON.stringify({
        type: 'ui',
        action: 'fetch_ohlcv',
        exchange: state.settings.exchange,
        symbol: state.settings.symbol,
        timeframe: state.settings.timeframe,
        limit: 200
      }));
    }

    function openChart() {
      els.chartModal.classList.add('show');
      document.getElementById('chartSymbol').textContent = state.chart.symbol || state.settings.symbol;
      requestChart();
      setTimeout(drawChart, 100);
    }

    function closeChart() {
      els.chartModal.classList.remove('show');
    }

    function updateChartStats() {
      const ohlcv = state.chart.ohlcv || [];
      if (!ohlcv.length) return;

      const last = ohlcv[ohlcv.length - 1];
      const first = ohlcv[0];
      const price = last[4];
      const open = first[1];
      const change = ((price - open) / open * 100).toFixed(2);
      const high = Math.max(...ohlcv.map(c => c[2]));
      const low = Math.min(...ohlcv.map(c => c[3]));

      document.getElementById('statPrice').textContent = '$' + price.toLocaleString();
      
      const changeEl = document.getElementById('stat24h');
      changeEl.textContent = (change >= 0 ? '+' : '') + change + '%';
      changeEl.className = 'chart-stat-value ' + (change >= 0 ? 'up' : 'down');
      
      document.getElementById('statHigh').textContent = '$' + high.toLocaleString();
      document.getElementById('statLow').textContent = '$' + low.toLocaleString();
      
      document.getElementById('chartMeta').textContent = `${state.chart.timeframe} ‚Ä¢ ${ohlcv.length} candles`;
    }

    function drawChart() {
      const canvas = els.chartCanvas;
      const wrap = canvas.parentElement;
      const dpr = window.devicePixelRatio || 1;
      const w = wrap.clientWidth;
      const h = wrap.clientHeight;
      
      canvas.width = w * dpr;
      canvas.height = h * dpr;
      canvas.style.width = w + 'px';
      canvas.style.height = h + 'px';
      
      const ctx = canvas.getContext('2d');
      ctx.scale(dpr, dpr);
      ctx.clearRect(0, 0, w, h);

      const ohlcv = state.chart.ohlcv || [];
      if (!ohlcv.length) {
        ctx.fillStyle = 'rgba(0, 255, 136, 0.3)';
        ctx.font = '14px system-ui';
        ctx.fillText('No data', w/2 - 30, h/2);
        return;
      }

      // Grid
      ctx.strokeStyle = 'rgba(0, 255, 136, 0.1)';
      ctx.lineWidth = 1;
      for (let i = 0; i <= 5; i++) {
        const y = (h / 5) * i;
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(w, y);
        ctx.stroke();
      }

      const closes = ohlcv.map(c => c[4]);
      const minY = Math.min(...closes);
      const maxY = Math.max(...closes);
      const pad = (maxY - minY) * 0.1 || 1;
      const lo = minY - pad, hi = maxY + pad;

      const xScale = (i) => (i / (ohlcv.length - 1)) * (w - 20) + 10;
      const yScale = (v) => h - ((v - lo) / (hi - lo) * (h - 20) + 10);

      // Gradient fill
      const gradient = ctx.createLinearGradient(0, 0, 0, h);
      gradient.addColorStop(0, 'rgba(0, 255, 136, 0.25)');
      gradient.addColorStop(1, 'rgba(0, 255, 136, 0)');

      ctx.beginPath();
      ctx.moveTo(xScale(0), h);
      for (let i = 0; i < ohlcv.length; i++) {
        ctx.lineTo(xScale(i), yScale(closes[i]));
      }
      ctx.lineTo(xScale(ohlcv.length - 1), h);
      ctx.closePath();
      ctx.fillStyle = gradient;
      ctx.fill();

      // Line
      ctx.strokeStyle = '#00ff88';
      ctx.lineWidth = 2;
      ctx.shadowColor = 'rgba(0, 255, 136, 0.5)';
      ctx.shadowBlur = 8;
      ctx.beginPath();
      for (let i = 0; i < ohlcv.length; i++) {
        const x = xScale(i);
        const y = yScale(closes[i]);
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.stroke();
      ctx.shadowBlur = 0;

      // Price label
      ctx.fillStyle = '#00ff88';
      ctx.font = 'bold 14px SF Mono, monospace';
      ctx.fillText('$' + closes[closes.length - 1].toLocaleString(), 12, 24);
    }

    // Theme
    function applyTheme(theme) {
      if (!theme) return;
      const root = document.documentElement;
      const map = {
        'neon': '--neon', 'neon_dim': '--neon-dim', 'neon_glow': '--neon-glow',
        'neon_subtle': '--neon-subtle', 'neon_border': '--neon-border',
        'bg': '--bg', 'text': '--text', 'text_dim': '--text-dim',
        'muted': '--muted', 'good': '--good', 'bad': '--bad', 'warn': '--warn'
      };
      for (const [key, cssVar] of Object.entries(map)) {
        if (theme[key]) root.style.setProperty(cssVar, theme[key]);
      }
      localStorage.setItem('hashtradeTheme', JSON.stringify(theme));
    }

    // Utils
    function escapeHtml(s) {
      return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
    }

    function openSettings() {
      els.settingsModal.classList.add('show');
    }

    function closeSettings() {
      els.settingsModal.classList.remove('show');
    }

    // Auto-resize textarea
    els.chatInput.addEventListener('input', function() {
      this.style.height = 'auto';
      this.style.height = Math.min(this.scrollHeight, 120) + 'px';
    });

    // Event listeners
    els.btnSend.addEventListener('click', send);
    els.chatInput.addEventListener('keydown', e => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        send();
      }
    });

    document.getElementById('btnSettings').addEventListener('click', openSettings);
    document.getElementById('btnSettingsCancel').addEventListener('click', closeSettings);
    document.getElementById('btnSettingsSave').addEventListener('click', saveSettings);
    els.settingsModal.addEventListener('click', e => {
      if (e.target === els.settingsModal) closeSettings();
    });

    document.getElementById('chartFab').addEventListener('click', openChart);
    document.getElementById('chartClose').addEventListener('click', closeChart);

    document.getElementById('chartControls').addEventListener('click', e => {
      if (e.target.classList.contains('tf-btn')) {
        document.querySelectorAll('.tf-btn').forEach(b => b.classList.remove('active'));
        e.target.classList.add('active');
        state.settings.timeframe = e.target.dataset.tf;
        state.chart.timeframe = e.target.dataset.tf;
        requestChart();
      }
    });

    document.getElementById('btnClear').addEventListener('click', () => {
      if (state.ws && state.ws.readyState === 1) {
        state.ws.send(JSON.stringify({ type: 'history', action: 'clear' }));
      }
      clearTimeline();
      // Also clear time travel state
      state.streamEvents = [];
      state.streamSnaps = [];
      state.nowIndex = 0;
      state.isLive = true;
      els.timeFab.classList.remove('has-history');
      els.timeSlider.max = 0;
      els.timeSlider.value = 0;
      updateTimeReadout();
      updateLiveBadge();
    });

    // Time travel controls
    els.timeFab.addEventListener('click', openTimeTravel);
    document.getElementById('timeTravelClose').addEventListener('click', closeTimeTravel);
    document.getElementById('btnPlay').addEventListener('click', togglePlay);
    document.getElementById('btnPrev').addEventListener('click', () => setTimeIndex(state.nowIndex - 1));
    document.getElementById('btnNext').addEventListener('click', () => setTimeIndex(state.nowIndex + 1));
    document.getElementById('btnLive').addEventListener('click', goToLive);
    els.timeSlider.addEventListener('input', (e) => {
      state.isLive = false;
      setTimeIndex(parseInt(e.target.value, 10));
    });

    // Handle resize for chart
    window.addEventListener('resize', () => {
      if (els.chartModal.classList.contains('show')) {
        drawChart();
      }
    });

    // Init
    loadSettings();
    
    // Load saved theme
    try {
      const savedTheme = localStorage.getItem('hashtradeTheme');
      if (savedTheme) applyTheme(JSON.parse(savedTheme));
    } catch (e) {}

    // Auto-connect
    connect();

    // Register service worker
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('sw.js').catch(() => {});
    }
  </script>
</body>
</html>
